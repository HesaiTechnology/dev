"use strict";(globalThis.webpackChunkdocusaurus_wiki=globalThis.webpackChunkdocusaurus_wiki||[]).push([[7150],{2905(e,t,a){a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"how_to_guides/Serial_api","title":"Use Serial API","description":"Overview","source":"@site/docs/how_to_guides/Serial_api.md","sourceDirName":"how_to_guides","slug":"/how_to_guides/Serial_api","permalink":"/dev/docs/how_to_guides/Serial_api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"howToSidebar","previous":{"title":"Use TCP API","permalink":"/dev/docs/how_to_guides/TCP_api"},"next":{"title":"Synchronize Time using PTP","permalink":"/dev/docs/how_to_guides/ptp_sync_application"}}');var r=a(4848),i=a(8453),s=a(9030);const d={sidebar_position:5},o="Use Serial API",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Application Instructions",id:"application-instructions",level:2},{value:"Query Serial Port",id:"query-serial-port",level:3},{value:"Windows Systems",id:"windows-systems",level:4},{value:"Ubuntu Systems",id:"ubuntu-systems",level:4},{value:"Serial API Data Structure",id:"serial-api-data-structure",level:3},{value:"CMD Datagram Data Structure",id:"cmd-datagram-data-structure",level:4},{value:"ACK Datagram Data Structure",id:"ack-datagram-data-structure",level:4},{value:"Examples",id:"examples",level:2},{value:"Use LidarUtilities to Send Serial API Commands",id:"use-lidarutilities-to-send-serial-api-commands",level:3},{value:"Use a Script to Send Serial API Commands",id:"use-a-script-to-send-serial-api-commands",level:3}];function m(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"use-serial-api",children:"Use Serial API"})}),"\n",(0,r.jsx)(t.h2,{id:"overview",className:"numbered-heading","data-number":"1","data-text":"Overview","data-toc-number":"1",children:"1 Overview"}),"\n",(0,r.jsx)(t.p,{children:"Some Hesai lidar models support communication with a computer host using Serial API commands. These commands are sent via the RS232 protocol as command datagrams (CMD datagram) and received via the RS485 protocol as acknowledgment datagrams (ACK datagram). This enables control, operation, and query functionalities for the lidar."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Note: The current Serial API commands are only applicable to the JT16 lidar. For detailed command information, please refer to the JT16 Serial API Manual."})}),"\n",(0,r.jsx)(t.h2,{id:"application-instructions",className:"numbered-heading","data-number":"2","data-text":"Application Instructions","data-toc-number":"2",children:"2 Application Instructions"}),"\n",(0,r.jsx)(t.p,{children:"The application and basic operation steps for Serial API commands are as follows:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Connect the lidar to the host and ensure that communication is successfully established (refer to ",(0,r.jsx)(t.a,{href:"/dev/docs/how_to_guides/serial_port_config",children:"Configure Serial Port"})," for details)."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Send API commands from the host to the lidar via the serial port, receive responses from the lidar, and parse the responses according to the API manual to confirm whether the API command was successfully executed."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"query-serial-port",className:"numbered-heading","data-number":"2.1","data-text":"Query Serial Port","data-toc-number":"2.1",children:"2.1 Query Serial Port"}),"\n",(0,r.jsx)(t.h4,{id:"windows-systems",className:"numbered-heading","data-number":"2.1.1","data-text":"Windows Systems","data-toc-number":"2.1.1",children:"2.1.1 Windows Systems"}),"\n",(0,r.jsx)(t.p,{children:'If using a Windows system, open "Device Manager" to view the ports.'}),"\n",(0,r.jsx)(t.p,{children:"To distinguish between serial ports, user can first insert the RS485 cable into the USB port and note the port number, then insert the RS232 cable and note the newly recognized port number."}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/Windows_com_port.png"),alt:"Windows_com_port",style:{display:"block",margin:"0 auto",width:"50%"}}),"\n",(0,r.jsx)(t.h4,{id:"ubuntu-systems",className:"numbered-heading","data-number":"2.1.2","data-text":"Ubuntu Systems","data-toc-number":"2.1.2",children:"2.1.2 Ubuntu Systems"}),"\n",(0,r.jsx)(t.p,{children:"If using an Ubuntu system, user can enter the following command in the terminal to view the current ports:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"ls /dev/ttyUSB*\n"})}),"\n",(0,r.jsx)(t.p,{children:"To distinguish between serial ports, first insert the RS485 cable into the USB port and note the port number, then insert the RS232 cable and note the newly recognized port number."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Note:"})}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["On Ubuntu, the full port name is ",(0,r.jsx)(t.code,{children:"/dev/ttyUSB*"}),". When connecting via a script, the full name must be entered."]}),"\n",(0,r.jsx)(t.li,{children:"If the connection fails due to insufficient permissions, enter the following command to grant the necessary permissions:"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"sudo chmod 666 /dev/ttyUSB*\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Pleaes refer to the ",(0,r.jsx)(t.a,{href:"/dev/docs/how_to_guides/serial_port_config#configuration-process",children:"Configure Serial Port - Process"})," section for detailed instructions."]}),"\n",(0,r.jsx)(t.h3,{id:"serial-api-data-structure",className:"numbered-heading","data-number":"2.2","data-text":"Serial API Data Structure","data-toc-number":"2.2",children:"2.2 Serial API Data Structure"}),"\n",(0,r.jsx)(t.h4,{id:"cmd-datagram-data-structure",className:"numbered-heading","data-number":"2.2.1","data-text":"CMD Datagram Data Structure","data-toc-number":"2.2.1",children:"2.2.1 CMD Datagram Data Structure"}),"\n",(0,r.jsx)(t.p,{children:"The host sends command datagrams (CMD datagram) to the lidar via RS232 communication. The data structure of the command datagram is shown below:"}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/cmd_datagram.png"),alt:"cmd_datagram",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsxs)(t.p,{children:['The CRC checksum uses the CRC-32/MPEG-2 algorithm, calculated from the "Data Length" to "Check ID" fields. Users can calculate the CRC using online CRC tools or the script provided ',(0,r.jsx)(t.a,{href:"#use-a-script-to-send-serial-api-commands",children:"here"})," from this document. The CRC result is filled into the command datagram in little-endian format (low byte first)."]}),"\n",(0,r.jsx)(t.h4,{id:"ack-datagram-data-structure",className:"numbered-heading","data-number":"2.2.2","data-text":"ACK Datagram Data Structure","data-toc-number":"2.2.2",children:"2.2.2 ACK Datagram Data Structure"}),"\n",(0,r.jsx)(t.p,{children:"After the command datagram (CMD datagram) is sent, the host receives acknowledgment datagrams (ACK datagram) from the lidar via RS485 communication. The data structure of the acknowledgment datagram is shown below:"}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/ack_datagram-1.png"),alt:"ack_datagram-1",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/ack_datagram-2.png"),alt:"ack_datagram-2",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:['Note: Similar to command datagrams, point cloud packets are also transmitted via RS485 communication. Users need to filter acknowledgment datagrams (ACK datagram) from the RS485 data stream based on the "Frame Header" and "End of Frame" fields. Parse the "Fault Code" field in the acknowledgment datagram. If the field is ',(0,r.jsx)(t.code,{children:"0"}),', the command was successfully executed. If it contains other values, refer to the "Description" section of the field from the image above for troubleshooting.']})}),"\n",(0,r.jsx)(t.h2,{id:"examples",className:"numbered-heading","data-number":"3","data-text":"Examples","data-toc-number":"3",children:"3 Examples"}),"\n",(0,r.jsx)(t.p,{children:"This document introduces two different methods for sending Serial API commands, along with corresponding examples. Users can choose one based on their actual needs."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Note: Before using Serial API commands, refer to the product manual to confirm that the command configuration is valid for the lidar being used."})}),"\n",(0,r.jsx)(t.h3,{id:"use-lidarutilities-to-send-serial-api-commands",className:"numbered-heading","data-number":"3.1","data-text":"Use LidarUtilities to Send Serial API Commands","data-toc-number":"3.1",children:"3.1 Use LidarUtilities to Send Serial API Commands"}),"\n",(0,r.jsxs)(t.p,{children:["Refer to the ",(0,r.jsx)(t.a,{href:"/dev/docs/how_to_guides/LidarUtilities#common-operation-instructions",children:"Use LidarUtilities"})," document for information on obtaining and using the LidarUtilities software."]}),"\n",(0,r.jsx)(t.p,{children:'Power on the JT16 lidar and connect it to the host. For example, on a Windows system, open LidarUtilities, select the product model as JT16, configure the RS485 port, RS232 port, and baud rate (note: the standard baud rate is 3000000, and the non-standard baud rate is 3125000; if unsure, try both), and click "Connect." Once connected successfully, the interface will appear as shown below:'}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/LU_connection.png"),alt:"LU_connection",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)(t.p,{children:"For example, to send a command to set the motor speed, the specific configuration parameters for the command datagram are shown below:"}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/switch_motor_speed_cmd_datagram-1.png"),alt:"switch_motor_speed_cmd_datagram-1",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/switch_motor_speed_cmd_datagram-2.png"),alt:"switch_motor_speed_cmd_datagram-2",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:'Note: For detailed command instructions, refer to the "2.2 Switch motor speed" section of the JT16 API manual.'})}),"\n",(0,r.jsx)(t.p,{children:"The method for sending serial commands is shown below:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:'Switch to the "Send Serial Command" page.'}),"\n",(0,r.jsxs)(t.li,{children:['In the "Send Command - Command Code" section, enter ',(0,r.jsx)(t.code,{children:"03"})," (CMD ID)."]}),"\n",(0,r.jsxs)(t.li,{children:['In the "Payload" section, enter ',(0,r.jsx)(t.code,{children:"0A 01"})," (CMD DATA, 10Hz), leaving a space between the values."]}),"\n",(0,r.jsx)(t.li,{children:'Click "Send" to send the command.'}),"\n"]}),"\n",(0,r.jsx)("img",{src:(0,s.Ay)("/img/switch_motor_speed_LU_operation_steps.jpg"),alt:"switch_motor_speed_LU_operation_steps",style:{display:"block",margin:"0 auto",width:"80%"}}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:['Note: This command is only provided as an example. Since JT16 currently does not support setting the motor speed to 10Hz, the "Fault Code" in the ACK datagram will display ',(0,r.jsx)(t.code,{children:"1"}),'. While for any supported commands, the expected "Fault Code" in the acknowledgment datagram should be ',(0,r.jsx)(t.code,{children:"0"}),"."]})}),"\n",(0,r.jsx)(t.h3,{id:"use-a-script-to-send-serial-api-commands",className:"numbered-heading","data-number":"3.2","data-text":"Use a Script to Send Serial API Commands","data-toc-number":"3.2",children:"3.2 Use a Script to Send Serial API Commands"}),"\n",(0,r.jsx)(t.p,{children:'Similarly, to send a command to set the motor speed, users can use the following python script to perform the corresponding operation. The script primarily handles CMD command packaging and sending. After configuring the RS232 port, baud rate, command ID, and command content, the script will automatically calculate the data length and CRC checksum, complete the packaging, and send the command. Users can verify whether the command was successfully executed by checking the expected effect or capturing the ACK datagram and examining the "Fault Code" field.'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\n# """\n\n# - Simplified version: build and send CMD frame only (no ACK listening)\n\n# - Configurable CMD parameters, compute CRC32/MPEG-2 (little-endian)\n\n# """\n\nimport serial\n\n# -------------------- USER CONFIGURATION AREA --------------------\n\n# Serial settings\n\nRS232_PORT = "COM4"          # RS232 port\nRS232_BAUD = 9600            # RS232 baud rate\n\n# RS485_PORT = "COM5"          #RS485 port\n\n# RS485_BAUD = 3000000          # RS485 baud rate\n\n# CMD parameters\n\nCMD_ID = 0x03                # Command ID\nCMD_DATA = bytes.fromhex(\'0A 01\')  # Command data segment\n\n# -------------------- USER CONFIGURATION AREA --------------------\n\n# Frame constants--------------------------------------------------\n\nCHECK_ID = bytes.fromhex(\'95 B3 2C 0A\')  # 4-byte check ID\nFRAME_HEADER_CMD = b"\\x24\\x4C\\x44\\x43\\x4D\\x44\\x2C"  # CMD header\nFRAME_END = b"\\xEE\\xFF"                              # Frame tail\n\n# -----------------------------------------------------------------\n\n# -------------------- CRC32/MPEG-2 CALCULATION -----------------\n\ndef init_crc32_mpeg2_table() -> list[int]:\n    # """Initialize CRC32/MPEG-2 lookup table"""\n    crc_table =[0]*256\n    for i in range(256):\n        crc = i << 24\n        for _ in range(8):\n            crc = (crc << 1) ^ 0x04C11DB7 if crc & 0x80000000 else crc << 1\n        crc_table[i] = crc & 0xFFFFFFFF\n    return crc_table\n\nCRC_TABLE = init_crc32_mpeg2_table()\n\ndef crc32_mpeg2(data: bytes) -> int:\n    # """Compute CRC32/MPEG-2 checksum (unsigned 32-bit)"""\n    if not data:\n        return 0xFFFFFFFF\n    crc = 0xFFFFFFFF\n    for b in data:\n        crc = ((crc << 8) ^ CRC_TABLE[(crc >> 24) ^ b]) & 0xFFFFFFFF\n    return crc\n\ndef build_cmd(cmd_id: int, cmd_data: bytes, check_id: bytes) -> bytes:\n    # """\n    # Automatically build CMD frame (with CRC)\n    # :param cmd_id: Command ID (1 byte)\n    # :param cmd_data: Command data segment\n    # :param check_id: 4-byte check ID\n    # :return: Complete CMD frame (header + payload + CRC + tail)\n    # """\n    # 1. Build base payload (length + CMD_ID + CMD_DATA)\n    data_len = 1 + len(cmd_data)  # CMD_ID(1 byte) + CMD_DATA length\n    payload = bytes([data_len, cmd_id]) + cmd_data\n\n    # 2. Align to 4-byte boundary (whole payload + check_id)\n    total_payload_len = len(payload) + len(check_id)\n    pad_len = (4 - total_payload_len % 4) % 4\n    payload += b"\\x00" * pad_len\n\n    # 3. Append CHECK_ID\n    payload += check_id\n\n    # 4. Compute CRC (little-endian)\n    crc_value = crc32_mpeg2(payload)\n    crc_bytes = crc_value.to_bytes(4, byteorder="little")  # low byte first\n\n    # 5. Assemble full frame\n    full_cmd = FRAME_HEADER_CMD + payload + crc_bytes + FRAME_END\n    return full_cmd\n\n# -------------------- MAIN (construct + send CMD only) ---------\n\ndef main():\n    # 1. Build CMD frame\n    try:\n        cmd_frame = build_cmd(CMD_ID, CMD_DATA, CHECK_ID)\n        print("========== Build CMD frame ==========")\n        print(f"Hex: {cmd_frame.hex(\' \').upper()}")\n        print(f"Length: {len(cmd_frame)} bytes")\n        print("=========================================")\n    except Exception as e:\n        print(f"Failed to build CMD frame: {e}")\n        return\n\n    # 2. Send CMD frame (RS232)\n    try:\n        with serial.Serial(\n            port=RS232_PORT,\n            baudrate=RS232_BAUD,\n            timeout=1,\n            parity=serial.PARITY_NONE,\n            stopbits=serial.STOPBITS_ONE,\n            bytesize=serial.EIGHTBITS\n        ) as ser_232:\n            ser_232.reset_input_buffer()\n            ser_232.reset_output_buffer()\n            ser_232.write(cmd_frame)\n            ser_232.flush()\n            print("CMD frame sent")\n    except serial.SerialException as e:\n        print(f"Failed to send CMD frame: {e}")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Note: This script is only provided as an example. JT16 currently does not support setting the motor speed to 10Hz."})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453(e,t,a){a.d(t,{R:()=>s,x:()=>d});var n=a(6540);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);