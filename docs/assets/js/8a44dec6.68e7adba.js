"use strict";(globalThis.webpackChunkdocusaurus_wiki=globalThis.webpackChunkdocusaurus_wiki||[]).push([[1412],{3646(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"how_to_guides/Angle-Correction-File","title":"Acquire Angle Correction File","description":"Overview","source":"@site/docs/how_to_guides/Angle-Correction-File.md","sourceDirName":"how_to_guides","slug":"/how_to_guides/Angle-Correction-File","permalink":"/dev/docs/how_to_guides/Angle-Correction-File","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"howToSidebar","previous":{"title":"Synchronize Azimuth Angle","permalink":"/dev/docs/how_to_guides/sync_angle"},"next":{"title":"Acquire and Parse IMU Data","permalink":"/dev/docs/how_to_guides/Get_IMU_data"}}');var i=t(4848),a=t(8453),s=t(9030);const o={sidebar_position:9},d="Acquire Angle Correction File",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Application Instructions",id:"application-instructions",level:2},{value:"Using PandarView2",id:"using-pandarview2",level:3},{value:"Using API Commands",id:"using-api-commands",level:3},{value:"Ethernet Connection",id:"ethernet-connection",level:4},{value:"CSV Format",id:"csv-format",level:5},{value:"DAT Format",id:"dat-format",level:5},{value:"Serial Port Connection",id:"serial-port-connection",level:4},{value:"Serial Port Connection",id:"serial-port-connection-1",level:5},{value:"Examples",id:"examples",level:2},{value:"Acquiring Angle Correction File Using PandarView2",id:"acquiring-angle-correction-file-using-pandarview2",level:3},{value:"Acquiring Angle Correction File Using API Commands",id:"acquiring-angle-correction-file-using-api-commands",level:3},{value:"Ethernet Connection",id:"ethernet-connection-1",level:4},{value:"CSV Format",id:"csv-format-1",level:5},{value:"DAT Format",id:"dat-format-1",level:5},{value:"Serial Port Connection",id:"serial-port-connection-2",level:4}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"acquire-angle-correction-file",children:"Acquire Angle Correction File"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",className:"numbered-heading","data-number":"1","data-text":"Overview","data-toc-number":"1",children:"1 Overview"}),"\n",(0,i.jsx)(n.p,{children:'The angle correction file serves as the directional reference for system calibration, point cloud calculation, and spatial positioning. To ensure measurement accuracy, Hesai performs independent angle calibration for each Lidar unit during manufacturing. The calibration results are unique for each unit, and this unique correction data is recorded as the "angle correction file" which is provided within the Lidar.'}),"\n",(0,i.jsxs)(n.p,{children:["Lidar connection methods include ",(0,i.jsx)(n.strong,{children:"Ethernet connection"})," and ",(0,i.jsx)(n.strong,{children:"serial port connection"}),". The angle correction file formats include ",(0,i.jsx)(n.strong,{children:"CSV format"})," and ",(0,i.jsx)(n.strong,{children:"DAT format"}),". Please refer to the table below for specific models."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Lidar Models and Connection Methods Table:"})})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Connection Method"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Ethernet Connection"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Serial Connection"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Product Series"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Pandar, OT, QT, XT, AT, FT, JT"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"JT"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Applicable Models"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Pandar40P, Pandar64, Pandar128E3X, OT128, QT64C1X, QT128C2X, XT32, XT16, XT32M2X, AT128E2X, AT128P, ATX, FTX, JT128"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"JT16"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Lidar Models and File Formats Table:"})})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"File Format"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"CSV Format"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"DAT Format"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Product Series"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Pandar, OT, QT, XT, JT"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"AT, JT, FT"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"Applicable Models"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"Pandar40P, Pandar64, Pandar128E3X, OT128, PandarQT, QT128C2X, XT32, XT16, XT32M2X, JT128"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"AT128E2X, AT128P, ATX, JT16, FTX"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"application-instructions",className:"numbered-heading","data-number":"2","data-text":"Application Instructions","data-toc-number":"2",children:"2 Application Instructions"}),"\n",(0,i.jsx)(n.h3,{id:"using-pandarview2",className:"numbered-heading","data-number":"2.1","data-text":"Using PandarView2","data-toc-number":"2.1",children:"2.1 Using PandarView2"}),"\n",(0,i.jsx)(n.h3,{id:"using-api-commands",className:"numbered-heading","data-number":"2.2","data-text":"Using API Commands","data-toc-number":"2.2",children:"2.2 Using API Commands"}),"\n",(0,i.jsx)(n.h4,{id:"ethernet-connection",className:"numbered-heading","data-number":"2.2.1","data-text":"Ethernet Connection","data-toc-number":"2.2.1",children:"2.2.1 Ethernet Connection"}),"\n",(0,i.jsx)(n.h5,{id:"csv-format",children:(0,i.jsx)(n.a,{href:"#csv-format-1",children:"CSV Format"})}),"\n",(0,i.jsx)(n.h5,{id:"dat-format",children:(0,i.jsx)(n.a,{href:"#dat-format-1",children:"DAT Format"})}),"\n",(0,i.jsx)(n.h4,{id:"serial-port-connection",className:"numbered-heading","data-number":"2.2.2","data-text":"Serial Port Connection","data-toc-number":"2.2.2",children:"2.2.2 Serial Port Connection"}),"\n",(0,i.jsx)(n.h5,{id:"serial-port-connection-1",children:(0,i.jsx)(n.a,{href:"#serial-port-connection-2",children:"Serial Port Connection"})}),"\n",(0,i.jsx)(n.p,{children:"This document provides examples of how to obtain the angle correction file using the two methods mentioned above. You can choose one or more methods based on your actual situation."}),"\n",(0,i.jsx)(n.h2,{id:"examples",className:"numbered-heading","data-number":"3","data-text":"Examples","data-toc-number":"3",children:"3 Examples"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Note: The following examples are based on the user and command manuals for XT32, AT128P, and JT16. The configuration of different Lidar models may vary. Please refer to the user manual for the specific model."})}),"\n",(0,i.jsx)(n.h3,{id:"acquiring-angle-correction-file-using-pandarview2",className:"numbered-heading","data-number":"3.1","data-text":"Acquiring Angle Correction File Using PandarView2","data-toc-number":"3.1",children:"3.1 Acquiring Angle Correction File Using PandarView2"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Visit Hesai's ",(0,i.jsx)(n.a,{href:"https://www.hesaitech.com/product_downloads/pandarview-2/",children:"official website"})," to download and install the PandarView2 client."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Connect the Lidar to the computer host and ensure that communication is successfully established between the Lidar and the host. (For Ethernet connection methods, refer to ",(0,i.jsx)(n.a,{href:"/dev/docs/how_to_guides/network_config",children:"How to Configure Ethernet"}),"; for serial port connection methods, refer to the relevant Lidar user manual.)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Open PandarView2, click the [Listen for Data] button in the top-left toolbar. The Lidar connection methods include ",(0,i.jsx)(n.strong,{children:"Ethernet connection"})," and ",(0,i.jsx)(n.strong,{children:"serial port connection"}),", and the configuration methods differ slightly. Fill in the parameters according to the actual Lidar configuration."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Note: For serial port connections, the PandarView2 version must be greater than 2.1.7. Select the Serial Port option in the popout window and fill in the RS485 serial port address and baud rate. Reference model: JT16."})})}),"\n",(0,i.jsx)("img",{src:(0,s.Ay)("/img/pandarview_connect.png"),alt:"pandarview_connect",style:{display:"block",margin:"0 auto",width:"auto"}}),"\n",(0,i.jsx)(n.p,{children:"After completing the parameter configuration, click [OK] to confirm."}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"Click the [Correction] button in the toolbar, go to the Angle Correction section, and click 'Export'. In the popup window, enter the file name, select the save location, and click 'Confirm' to complete the export."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Note: When saving files on Ubuntu systems, you must add the correct file format extension (.csv/.dat)."})})}),"\n",(0,i.jsx)("img",{src:(0,s.Ay)("/img/pandarview_export.png"),alt:"pandarview_export",style:{display:"block",margin:"0 auto",width:"auto"}}),"\n",(0,i.jsx)(n.h3,{id:"acquiring-angle-correction-file-using-api-commands",className:"numbered-heading","data-number":"3.2","data-text":"Acquiring Angle Correction File Using API Commands","data-toc-number":"3.2",children:"3.2 Acquiring Angle Correction File Using API Commands"}),"\n",(0,i.jsx)(n.h4,{id:"ethernet-connection-1",className:"numbered-heading","data-number":"3.2.1","data-text":"Ethernet Connection","data-toc-number":"3.2.1",children:"3.2.1 Ethernet Connection"}),"\n",(0,i.jsx)(n.h5,{id:"csv-format-1",className:"numbered-heading","data-number":"3.2.1.1","data-text":"CSV Format","data-toc-number":"3.2.1.1",children:"3.2.1.1 CSV Format"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Reference Model: XT32"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"After connecting the Lidar to the host, open the script below using an IDE:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import socket, ssl, pprint, time\nimport random\nimport struct\n\ndefault_host = "192.168.1.201" # Change this to your Lidar IP\ndefault_port = 9347 # Change this to your Lidar PTC Port\n\nclass PTC:\n    def __init__(self, host=default_host, port=default_port):\n        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        lp = random.randint(10000, 30000)\n        self.s.bind((\'0.0.0.0\', lp))\n        self.s.settimeout(30)\n        self.s.connect((host, port))\n\n    def closeSocket(self):\n        self.s.shutdown(1)\n        # self.s.close()\n\n    def ByteToHex(self, h):\n        return \'\'.join(["%02x" % x for x in h]).strip()\n\n    def read_bytes(self, payload_size):\n        chunks = []\n        bytes_received = 0\n        while bytes_received < payload_size:\n            chunk = self.s.recv(payload_size - bytes_received)\n            if chunk == b"":\n                raise RuntimeError("Socket has been unexpectedly closed")\n            chunks.append(chunk)\n            bytes_received = bytes_received + len(chunk)\n\n        return b"".join(chunks)\n\n    def sender(self, cmd_code, payload):\n        """\n        :param cmd_code:\n        :param payload: payload should input like \'015d010207\'\n        :return:\n        """\n        if cmd_code in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'a\', \'b\', \'c\', \'d\', \'e\',\n                        \'f\']:\n            cmd_code = "0" + str(cmd_code)\n        print("payload :")\n        print(payload)\n        if not payload or payload.upper() == "NONE":\n            payload_len = 0\n            p = \'4774\' + str(cmd_code) + "00" + struct.pack(\'>L\', payload_len).hex()\n        else:\n            payload_len = len(bytes.fromhex(payload))\n            p = \'4774\' + str(cmd_code) + "00" + struct.pack(\'>L\', payload_len).hex() + payload\n        data = bytes.fromhex(p)\n        self.s.send(data)\n        response = self.s.recv(8)\n        print("response: ")\n        print(response)\n        r_cmd = bytes.hex(response[2:3])\n        r_returnCode = bytes.hex(response[3:4])\n        if bytes.hex(response[4:8]) == "\\x00\\x00\\x00\\x00":\n            r_length = 0\n            response_payload = ""\n        else:\n            r_length = int(bytes.hex(response[4:8]), 16)\n            response_payload = self.read_bytes(r_length)\n        print("command is: %s, get return code: %s, return length: %s, \\nreturn string:\\n%s" % (\n            r_cmd, r_returnCode, r_length, response_payload))\n        final_response = {\n            "response_command": r_cmd,\n            "response_return_code": r_returnCode,\n            "response_payload_length": r_length,\n            "response_payload": response_payload\n        }\n        return final_response\n\nif __name__ == "__main__":\n    ss = PTC()\n    print(ss.sender(\'05\', None)) # Example command to \'Get Current Fault Log\', change the command code and payload as needed\n\n    # save it as a CSV file\n    response = ss.sender(\'05\', None)\n    correction_data = response.get("response_payload", b"")\n    with open("angle_correction.csv", "wb") as f:\n        f.write(correction_data)\n    print("The data has been saved as angle_correction.csv.")\n\n    ss.closeSocket()\n'})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Configure the necessary Python environment in the host computer. Locate to lines 5 and 6 in the above script:"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'default_host = "192.168.1.201"'})," and ",(0,i.jsx)(n.code,{children:"default_port = 9347"})," \u2192 Replace ",(0,i.jsx)(n.code,{children:'"192.168.1.201"'})," and ",(0,i.jsx)(n.code,{children:"9347"})," with the actual IP address and port number of the Lidar, then run the script."]}),"\n",(0,i.jsxs)(n.p,{children:["After successful execution, an angle correction file named ",(0,i.jsx)(n.code,{children:"angle_correction.csv"})," will be generated in the current directory."]}),"\n",(0,i.jsx)(n.h5,{id:"dat-format-1",className:"numbered-heading","data-number":"3.2.1.2","data-text":"DAT Format","data-toc-number":"3.2.1.2",children:"3.2.1.2 DAT Format"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Reference Model: AT128P"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"After connecting the Lidar to the host, open the script below using an IDE:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from socket import *\n\nsock = socket(AF_INET,SOCK_STREAM)\n\nmessage = bytearray()\nmessage1 = bytearray()\nSN = bytearray()\n\n# header\n\nmessage.append(0x47)\nmessage.append(0x74)\n\n# command\n\n##################################################################\nmessage.append(0x05) #0x05 for Get Angle Correction File\n##################################################################\n\n# return code\n\nmessage.append(0x00)\n\n# Tail\n\nmessage.append(0x00)\nmessage.append(0x00)\nmessage.append(0x00)\nmessage.append(0x00) #0x01 payload data length for the command\nmessage.append(0x00) #payload data value, 0x01 means PTP STATUS\n\nsock.connect((\"192.168.1.201\",9347))#the ip of device and Port you need to call(fixed)\n\nsock.send(message)\nresponse=sock.recv(8)\nr_cmd = int.from_bytes(response[2:3], 'big')\nr_returnCode = int.from_bytes(response[3:4], 'big')\nr_length = int.from_bytes(response[4:8], 'big')\nresponse_payload=b''\nwhile len(response_payload) < r_length:\n    response_payload += sock.recv(r_length)\n\nprint(response_payload)\nwith open(\"corrections.dat\",\"wb\") as f:\n    f.write(response_payload)\nf.close()\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["CConfigure the necessary Python environment in the host computer. In the above script, locate to line 24: ",(0,i.jsx)(n.code,{children:'sock.connect(("192.168.1.201",9347))'})," \u2192 Replace ",(0,i.jsx)(n.code,{children:'"192.168.1.201"'})," and ",(0,i.jsx)(n.code,{children:"9347"})," with the actual IP address and port number of the Lidar, then run the code."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["After successful execution, an angle correction file named ",(0,i.jsx)(n.code,{children:"corrections.dat"})," will be generated in the current directory."]}),"\n",(0,i.jsx)(n.h4,{id:"serial-port-connection-2",className:"numbered-heading","data-number":"3.2.2","data-text":"Serial Port Connection","data-toc-number":"3.2.2",children:"3.2.2 Serial Port Connection"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Reference Model: JT16"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"After completing the connection between the Lidar and the host as described in the user manual, open the script below using an IDE:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import struct\nimport csv\nimport serial\nimport time\nfrom datetime import datetime\nfrom threading import Thread, Event\n\n\ndef parse_angle_data(valid_data):\n    # Ensure valid_data length is 68 bytes\n    if len(valid_data) != 68:\n        raise ValueError("Valid data length must be 68 bytes")\n\n    # Initialize lists to store angle values\n    azimuth_values = []\n    elevation_values = []\n\n    # Parse Azimuth data (first 32 bytes)\n    for i in range(16):\n        azimuth_bytes = valid_data[i * 2:(i + 1) * 2]\n        azimuth_value = struct.unpack(\'<h\', azimuth_bytes)[0] * 0.01  # Little-endian, short type, unit 0.01\xb0\n        azimuth_values.append(azimuth_value)\n\n    # Parse Elevation data (next 32 bytes)\n    for i in range(16):\n        elevation_bytes = valid_data[32 + i * 2:32 + (i + 1) * 2]\n        elevation_value = struct.unpack(\'<h\', elevation_bytes)[0] * 0.01  # Little-endian, short type, unit 0.01\xb0\n        elevation_values.append(elevation_value)\n\n    return azimuth_values, elevation_values\n\n\ndef save_to_csv(elevation_values, azimuth_values, output_file):\n    with open(output_file, \'w\', newline=\'\') as csvfile:\n        fieldnames = [\'Channel\', \'Elevation (\xb0)\', \'Azimuth (\xb0)\']\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n\n        writer.writeheader()\n        for i in range(16):\n            writer.writerow({\n                \'Channel\': i + 1,\n                \'Elevation (\xb0)\': elevation_values[i],\n                \'Azimuth (\xb0)\': azimuth_values[i]\n            })\n\n\ndef get_angle_correction(send_port: str, receive_port: str, baudrate_UART: int, baudrate_485: int):\n    # Command configuration\n    COMMAND = bytes([\n        0x24, 0x4C, 0x44, 0x43, 0x4D, 0x44, 0x2C, 0x03,\n\n        0x02, 0x07, 0x00, 0x95, 0xB3, 0x2C, 0x0A,\n\n        0xD3, 0x86, 0x1F, 0xA3, 0xEE, 0xFF\n    ])\n\n    # Response pattern configuration\n    START_MARKER = bytes([0x24, 0x4C, 0x44, 0x41, 0x43, 0x4B,\n                          0x2C, 0x48, 0x02, 0x07, 0x00])\n    DATA_START_OFFSET = 12  # Start position of valid data\n    DATA_LENGTH = 68  # Length of data to extract\n    ERROR_CODE_OFFSET = 80  # Position of error code\n    TOTAL_TIMEOUT = 8  # Total timeout in seconds\n    PRE_READ_TIME = 0.5  # Pre-read time in seconds\n\n    class AsyncReader:\n        def __init__(self, ser):\n            self.ser = ser\n            self.buffer = bytearray()\n            self.stop_event = Event()\n            self.thread = None\n\n        def start(self):\n            self.thread = Thread(target=self._read_loop)\n            self.thread.start()\n\n        def _read_loop(self):\n            while not self.stop_event.is_set():\n                if self.ser.in_waiting > 0:\n                    chunk = self.ser.read(self.ser.in_waiting)\n                    self.buffer.extend(chunk)\n\n        def stop(self):\n            self.stop_event.set()\n            if self.thread.is_alive():\n                self.thread.join(timeout=1)\n\n        def get_buffer(self):\n            return bytes(self.buffer)\n\n    try:\n        # Generate timestamped filenames\n        timestamp = datetime.now().strftime(\'%Y%m%d_%H%M%S\')\n        output_file = f"JT16_angle_correction_{timestamp}.dat"\n        log_file = f"JT16_angle_log_{timestamp}.txt"\n        csv_file = f"JT16_angle_correction_{timestamp}.csv"\n        # Open receiving port first\n        with serial.Serial(receive_port, baudrate_485, timeout=0) as ser_recv:  # Non-blocking mode\n            reader = AsyncReader(ser_recv)\n            reader.start()\n\n            # Start receiving data in advance\n            print(f"[{timestamp}] Starting pre-reception...")\n            time.sleep(PRE_READ_TIME)  # Pre-receive for 500ms\n            # Send command\n            with serial.Serial(send_port, baudrate_UART, timeout=1) as ser_send:\n                print(f"[{timestamp}] Sending command to {send_port}...")\n                ser_send.write(COMMAND)\n                ser_send.flush()\n\n            # Main processing loop\n            start_time = time.time()\n            found = False\n\n            with open(log_file, \'w\') as log:\n                log.write(f"Angle Correction Process Log - {timestamp}\\n")\n                log.write("=" * 50 + "\\n")\n\n                while (time.time() - start_time) < TOTAL_TIMEOUT:\n                    # Get current buffer\n                    current_buffer = reader.get_buffer()\n\n                    # Find start marker\n                    pos = current_buffer.find(START_MARKER)\n                    if pos != -1:\n                        # Calculate required end position\n                        required_end = pos + DATA_START_OFFSET + DATA_LENGTH + 1\n\n                        if len(current_buffer) >= required_end:\n                            # Extract response segment\n                            response = current_buffer[pos:required_end]\n\n                            # Verify data integrity\n                            if (response[11] == 0x44 and\n                                    response[ERROR_CODE_OFFSET] == 0x00):\n                                # Extract valid data\n                                valid_data = response[DATA_START_OFFSET:DATA_START_OFFSET + DATA_LENGTH]\n\n                                # Save as DAT file\n                                with open(output_file, \'wb\') as f:\n                                    f.write(valid_data)\n\n                                # # Parse angle data\n                                # azimuth_values, elevation_values = parse_angle_data(valid_data)\n                                #\n                                # # Save as CSV file\n                                # save_to_csv(elevation_values, azimuth_values, csv_file)\n\n                                log.write(f"Data saved to {output_file}\\n")\n                                print(f"Correction file saved successfully: {output_file}")\n                                print(f"CSV file saved successfully: {csv_file}")\n                                found = True\n                                break\n\n                            # Clean up processed buffer\n                            reader.buffer = reader.buffer[required_end:]\n\n                    time.sleep(0.01)  # Reduce CPU usage\n\n                reader.stop()\n\n                if not found:\n                    error_msg = "No valid response received" if len(current_buffer) == 0 \\\n                        else f"Received {len(current_buffer)} bytes but no valid data found"\n                    log.write(f"Error: {error_msg}\\n")\n                    raise TimeoutError(error_msg)\n\n    except Exception as e:\n        error_msg = f"{type(e).__name__}: {str(e)}"\n        print(f"An error occurred: {error_msg}")\n        with open(log_file, \'a\') as log:\n            log.write(f"Error: {error_msg}\\n")\n        raise\n\n\nif __name__ == "__main__":\n    # Enter UART port, RS485 port, UART baud rate, RS485 baud rate respectively\n    # Example: Windows: COM*; Ubuntu: /dev/ttyUSB*\n    get_angle_correction("COM4", "COM5", 9600, 3000000)\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Configure the necessary Python environment in the host computer, and modify the ",(0,i.jsx)(n.strong,{children:"RS485"})," and ",(0,i.jsx)(n.strong,{children:"RS232"})," port numbers and baud rates in the last line of the script. Note that the device names for the same serial port differ between Windows and Ubuntu systems (e.g., COM* for Windows, /dev/ttyUSB* for Ubuntu)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Run the script to generate an angle correction file named ",(0,i.jsx)(n.code,{children:"JT16_angle_correction_<current_time>.dat"})," and a corresponding log file in the current directory."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);